#일직선 주어지면 가장 많이 얻는 경우의 수 구하기 그런데 이게 왜 dp지?
#만약 모든 경우의 수를 찾는다고 치면 N^3 이구나...
#그럼 이전 결과가 다음 결과에 영향을 미친다는 건데 무조건 다이렉트로 영향을 미치는건 아니고, 짝수 길이 홀수 길이에 따라 다를거 같은데 아니야 마지막 인덱스를 가져간 경우에만 그 다음 인덱스 선택시 영향을 미치는구나. 비교하면 되겠네.

# 일단 숫자 입력 받기 첫째줄에 총 개수 둘째줄에 리스트
N = int(input())
data = list(map(int, input().split()))

DT = [0 for _ in range(101)]

DT[0] = data[0]
DT[1] = max(data[0], data[1])

# # 제한시간 30분안에 못풀어서 해설을 확인함
# 내가 막혔던 부분은 dptable을 이용하는 식은 알겠는데 그 dptable에 얘가 마지막인덱스를
# 포함했는지 그리고 그 마지막인덱스가 어디를 가리키고 있는지를 현재 호출중인 식에 어떻게 알릴건지를
# # 해결못하여 막막했는데 그럴 필요가 없었다.

# -> 단순하게 생각하기 -> 고려 대상을 너무 확장하지 말기 -> 단순하게 생각좀 하기!!!

# 어차피 이전에 저장된 값이 마지막 인덱스를 포함했는지 안했는지는 중요하지 않지, 나는
# 이전 방식과 이이전 방식 2가지 중에서 어떤걸 고를건지만 고르면 된다. 중간에 건너뛰고 선택하는 경우는 어떻게 고려해? 바텀업 하면서 알아서 정리 될거임. 큰값이 들어온 순간 이이전 방식+현재값으로 최대 경우의 수를 취합할거임. 어차피 '한칸'만 건너뛴다는 제약이니까
for i in range(2, N):
  DT[i] = max(DT[i - 2] + data[i], DT[i - 1])

print(DT[N - 1])
